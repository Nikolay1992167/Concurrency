# Задание

1. Создать любой gradle проект.
2. Придерживаться GitFlow: master -> develop -> feature/fix
3. Создать два класса:
      a) Клиент - имеет список данных в виде List<Integer>  от 1 до n. Отдельными потоками, по случайному индексу из 
         списка выбирается значение (метод remove()) и в виде запроса (класс с int-полем), содержащего это значение,
         отправляется на сервер в асинхронном режиме (например отправляются со случайной задержкой между запросами - 
         диапазон - от 100 до 500 мс).
         Количество запросов равно размеру первоначального списка.
         Контроль: после отправки всех запросов размер списка данных = 0.
      б) Сервер - получает запросы от клиента. Метод обрабатывающий запрос имеет задержку в виде рандомного инта.
         Диапазон - от 100 до 1000 мс. Сервер обрабатывает запросы, используя общий для всех потоков ресурс: 
         List<Integer>, в который складываются значения приходящие с запросом. В ответ от сервера передаем размер 
         листа на момент формирования ответа (класс с int полем). 
         Итоговый контроль правильности данных на стороне сервера: список(общий ресурс) должен содержать значения от 
         1 до n без пробелов, повторений, размерность его должна составлять n.
4. Клиент получает от сервера ответ и в общий для всех потоков ресурс accumulator суммирует значение из ответа 
от сервера. Итоговый контроль: accumulator = (1+n)*(n/2). Т.е. для диапазона 1-100 ответ должен быть 5050.
5. Протестировать эти два класса с проверкой многопоточность.
6. Протестировать взаимодействие клиента-сервера отдельным тестом (интеграционный) - обязательно.
7. В реализации использовать классы пакета java.util.concurrent (Обязательно Lock, Callable, Executor, Future, остальное по выбору)
8. Методы класса Object (относящиеся к потоку и монитору) и ключевое слово synchronized не использовать.

# Concurrency

Согласно условиям задания в проекте демонстрируется работа с потоками и задачами в Java, используя классы пакета java.util.concurrent.
В проекте реализованы два класса: Client и Server, которые взаимодействуют друг с другом по протоколу запрос-ответ. 
Клиент отправляет запросы на сервер в асинхронном режиме, используя случайные значения из списка данных. Сервер 
обрабатывает запросы, используя общий ресурс, в который складывает значения из запросов. Сервер возвращает ответы, 
содержащие размер ресурса на момент формирования ответа. Клиент получает ответы от сервера и суммирует их в атомарной переменной.
Класс Client имеет следующие поля и методы:
* data - поле типа List<Integer>, которое хранит список данных. Из него выбираются значения для запросов. Это поле 
инициализируется в конструкторе, заполняясь целыми числами от 1 до n, где n - параметр конструктора.
* executor - поле типа ExecutorService, которое хранит объект, который управляет выполнением задач в потоках. Это поле
инициализируется в конструкторе, создавая фиксированный пул потоков с заданным количеством, которое является параметром 
конструктора.
* lock - поле типа Lock, которое хранит объект, который позволяет создать блокировку, которая используется для 
синхронизации доступа к общим ресурсам между потоками. Это поле инициализируется в конструкторе, создавая объект типа ReentrantLock.
* accumulator - поле типа AtomicInteger, которое хранит объект, который позволяет работать с атомарной переменной типа 
int, которая используется для суммирования ответов от сервера. Это поле инициализируется в конструкторе, создавая объект
типа AtomicInteger с начальным значением 0.
* server - поле типа Server, которое хранит объект, который представляет сервер, который принимает и обрабатывает запросы 
от клиентов. Это поле инициализируется в конструкторе, создавая объект типа Server.
* sendRequest - метод, который отправляет запросы на сервер и получает ответы от него. Этот метод не принимает никаких 
параметров и не возвращает никакого значения. В этом методе создается список задач типа Callable<Request>, вызывая метод
createRequests, который преобразует список данных в список запросов, содержащих целочисленные значения. Затем запускаются
все задачи в потоках, вызывая метод invokeAll у объекта executor, который возвращает список объектов Future<Request>, 
которые представляют результаты выполнения задач. После все объекты Future<Request> преобразуются в объекты Response, 
вызывая метод processRequest у объекта server, который принимает объект Future<Request> и возвращает объект Response, 
содержащий размер ресурса на сервере.
Для каждого объекта Response выполняются следующие действия:
Добавляется значение из ответа к текущему значению атомарной переменной, вызывая метод accumulateAndGet у объекта 
accumulator, который принимает значение и функцию сложения и возвращает новое значение.
Записывается в журнал размер ресурса на сервере с помощью log.
Останавливается исполнитель, запрещая принимать новые задачи и дожидаясь завершения уже запущенных задач, вызывая 
метод shutdown у объекта executor.
Записываются в журнал информация о том, что клиент отправил все запросы на сервер и что размер списка данных равен 0, 
информация о том, что сервер обработал все запросы от клиента и что список ресурсов содержит значения от 1 до n без 
пробелов и повторений, информация о том, какое значение накопилось в атомарной переменной после суммирования всех ответов 
от сервера c помощью log.
* createRequests - метод, который создает список задач типа Callable<Request>, которые представляют запросы, содержащие 
целочисленные значения. Этот метод не принимает никаких параметров и возвращает список объектов типа Request.
Класс Server имеет следующие поля и методы:
* resourceList - поле типа List<Integer>, которое хранит список данных, которые получение в результате запросов клиента.
* processRequest - метод, в котором генерируется случайное время задержки от 100 до 1000 миллисекунд с помощью класса Random. 
Если по какой-то причине не удается сгенерировать случайное число, используется значение по умолчанию 100. Затем метод вызывает
TimeUnit.MILLISECONDS.sleep(delayTime), чтобы приостановить выполнение текущего потока на сгенерированное время задержки. 
Это симулирует задержку в обработке запроса. После задержки метод пытается получить объект Request из 
Future<Client.Request> future с помощью метода future.get(). Этот метод блокирует выполнение текущего потока до тех пор, 
пока результат не станет доступным. Из полученного объекта Request извлекается значение dataRequest и добавляется в 
список ресурсов resourceList. В конце метода возвращается новый объект Response, который содержит размер списка ресурсов.

### Технологии применённые в проекте

* Java 17
* Gradle 8.1.1
* Logback 1.4.11
* Junit-bom 5.9.2
* Junit-jupiter
* Assertj-core:3.24.2

### Unit тесты

Модульные тесты и интеграционный выполнены с использованием библиотеки AssertJ.
Согласно требованиям задания.
Вы можете запустить тесты для этого проекта, выполнив в корне проекта:
```
./gradlew test
```

### Функциональность

Для проверки функциональности программы можно также создать класс Main:
````
public class Main {
    public static void main(String[] args) {
        Client client = new Client(10, 4);
        client.sendRequest();
    }
}
````
При запуске, которого будет получено:
```
> Task :Main.main()
18:28:30.904 [main] INFO by.clevertec.entity.Client -- Resource size: 1
18:28:31.344 [main] INFO by.clevertec.entity.Client -- Resource size: 2
18:28:32.167 [main] INFO by.clevertec.entity.Client -- Resource size: 3
18:28:32.441 [main] INFO by.clevertec.entity.Client -- Resource size: 4
18:28:32.954 [main] INFO by.clevertec.entity.Client -- Resource size: 5
18:28:33.797 [main] INFO by.clevertec.entity.Client -- Resource size: 6
18:28:34.637 [main] INFO by.clevertec.entity.Client -- Resource size: 7
18:28:35.015 [main] INFO by.clevertec.entity.Client -- Resource size: 8
18:28:35.816 [main] INFO by.clevertec.entity.Client -- Resource size: 9
18:28:36.019 [main] INFO by.clevertec.entity.Client -- Resource size: 10
18:28:36.021 [main] INFO by.clevertec.entity.Client -- Client -> All requests sent. Data list size: 0
18:28:36.021 [main] INFO by.clevertec.entity.Client -- Server -> All requests processed. Resource list is: [1, 9, 10, 5, 6, 2, 8, 3, 4, 7]
18:28:36.021 [main] INFO by.clevertec.entity.Client -- Accumulator -> 55
```
Благодарю за уделённое время! Буду рад детальному ревью и хотел бы услышать мнение о README.md.